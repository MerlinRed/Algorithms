from collections import deque

graph = {
    'you': ['alice', 'bob', 'claire'],
    'bob': ['anuj', 'peggy'],
    'alice': ['peggy'],
    'claire': ['thom', 'johny'],
    'anuj': [],
    'peggy': [],
    'thom': [],
    'johny': ['carl'],
    'carl': []
}


def search_man(name):
    return 'carl' == name


def bfs(name):
    """Алгоритм поиска в ширину определенного значения в невзвешенном графе

        для начала создается граф по которому нужно искать
        этот граф представляет собой хэш-таблицу(словарь)
        где ключом является вершина, а значением его потомки(тоже вершины)

        далее создается очередь, чтобы поиск происходил по порядку, по уровням вложенности
        в очередь добавляется первая вершина со значениями(вершинами), от которой будем искать
        создается пустой список, куда будут добавлены просмотренные вершины,
        это делается для того чтобы не попасть в бесконечный цикл

        пока очередь не пустая, достаем из нее вершину по ключу,
        если такая вершина уже есть в списке, пропускаем, если нет
        начинаем сравнивать, является ли это тем что мы ищем, если да, найдено
        если нет,
        добавляем потомков этой вершины в очередь, а ее саму в список просмотренных,
        чтобы к ней больше не возвращаться

        и так продолжается пока не будет найдено значение, или не будут просмотрены все вершины

        трудоемкость O(V+E) - количество вершин + количество ребер

    """
    search_queue = deque()
    search_queue += graph[name]
    scanned = []
    while search_queue:
        person = search_queue.popleft()
        if person not in scanned:
            if search_man(person):
                path = scanned + [person]
                print(f'{person} found')
                print(f'{path[::-1]}')
            else:
                search_queue += graph[person]
                scanned.append(person)
    return False


bfs('you')
